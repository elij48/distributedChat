Assignment 2 - Distributed Chat - Part 2 Design
Jeremy Klein, Joshua Geyer, 
Elijah Macaranas, Damien Zapata




















Topology Description
In our last assignment, we came up with two approaches to implementing our Distributed Chat, one of which was to connect all clients to each other in the form of a LinkedList. In this assignment, we assume that we will be implementing a mesh topology to our chat. This approach is very similar to the method we had come with earlier in Assignment 1, where all clients are interconnected. In the new mesh topology, it will be much easier to manage connections, and will allow all users to accept join requests, since all clients will be connected to each other anyway. However, the implications of having interconnected clients could also make things more tricky, since a large number of clients will need many more connections. 






Class Diagrams
  







Activity Diagrams
  

Joining chat:
* New node sends its own information
* Every other node puts that information into their participant list
* Server sends back a list of participants
* New node connects to every other node




  

Sending out/receiving message:
* Message objects are sent over the network
* Messages objects are then received by every other node




  
Leaving the chat:
* Node sends message informing all other nodes that it is leaving
* All other nodes remove that node’s information from the participant list
* Node shuts down all of its connections






Messaging Protocol:


Sending/Receiving a message:
Let Node n be a node trying to send/receive a message to the m max number of nodes currently joined in the DistributedChat communication. Let n+1 be the generated uniqueID of the next node. 
The procedure of sending a message follows as such:
1. Node n, uses its main class’ sendMessage() method to get the user’s message input
2. The current node, Node n, uses its NodeClient class’ sendMessage() method to actually send the message(s) to other nodes’ NodeServer classes by using their uniqueID’s generated by the generateID() method when accepting connection w/ the other nodes
2.1   The order in which the messages will be sent is the order the uniqueIDs for all nodes was generated; meaning the first node that will receive the message will be n+1
  



The procedure of receiving a message go as follows:
1. Node n’s NodeServer class evokes the receiveMessage() method to receive messages from other nodes in the order in which the generated uniqueIDs was generated for all of the nodes
2. Node n’s main class will then get the message from the NodeServer class through the getMessage() method and displays it promptly in the order the message(s) was received first
  

Joining Chat:
The procedure of joining the chat go as follows:
1. NewNode sends its own information, including user name, uniqueID, it's IP address, etc. to one of the participating nodes using the client’s startConnection() method. This creates several joinMessage objects to the number of active participants.
1.1   If not participating, a node can simply invoke “join” then joinChat() method will execute itself. This method implies that the information is already sent before but not currently active or not within the participant list
2. One of the participating nodes will accept one of the NewNode’s joinMessage using the acceptConnection method of the NodeServer class. At this time, the other joinMessage objects will also be sent to other participating nodes
3. The participating node will then update its list of participants and send it to the new node and other participants. 
4. Once other participants receives the joinMessage object, they will also execute acceptConnection method
Leaving Chat:
The procedure of leaving the chat follows as such:
1. To leave, a node must invoke “leave”, then leaveChat() method will execute. This will create a leaveMessage objects up to the number of active participants
1.1   If the node of the user wants to join at a later time, it can be a non-participating node; only having or “knowing” one of the participants’ IP address and port number
1.2   To leave completely, not only leaveChat() will execute, but also endConnection() will, shutting down the communication between all other nodes
2. Send  the leave message objects to all participants, notifying them that the node will leave the chat
3. Once receiving the object, each participating node will remove the leaving node’s information and update their participant list accordingly. This is executed by the closeConnection() method